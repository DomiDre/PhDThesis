\providecommand{\main}{../../../..}
\documentclass[\main/dresen_thesis.tex]{subfiles}
\begin{document}
\section{Fortran: Superball}\label{ch:appendix:code:superball}
The superball form factor described in \refapp{ch:appendix:numericalMethods:superballFormfactor} was implemented in Fortran 90 to calculate fast and reliably the multiple integrals that are involved.

\lstset{language=[90]Fortran,
  basicstyle=\ttfamily,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  numbers=left,
  morecomment=[l]{!\ }% Comment only with space after !
}
\begin{lstlisting}
  double precision function ff_ampl_superball_oriented&
    (q, p, Np)
    ! Function to evaluate oriented superball FF amplitude
    ! Input:
    ! q -- scattering vector magnitude to evaluate
    ! p -- parameter array of:
    !      R         -- superball radius
    !      p_val     -- superball exponent
    !      SLDcore   -- SLD of superball
    !      SLDmatrix -- SLD of matrix
    !      alpha     -- polar angle of q vector
    !      beta      --  azimuthal angle of q vector
    ! Np -- Length of p, should be 6
    double precision, intent(in) :: q
    double precision, dimension(Np), intent(in) :: p
    integer, intent(in) :: Np

    double precision :: R, p_val, alpha, beta
    double precision :: SLDsuperball, SLDmatrix

    double precision :: qx, qy, qz
    double precision :: real_ff_superball
    double precision, dimension(Np) :: help_p

    ! Read in variables from parameter array
    ! For better code readability
    R = p(1)
    p_val = p(2)
    SLDsuperball = p(3)
    SLDmatrix = p(4)
    alpha = p(5)
    beta = p(6)

    ! Calculate q vector components
    qx = q * cos(alpha)*sin(beta)
    qy = q * sin(alpha)*sin(beta)
    qz = q * cos(beta)

    ! Perform integrals for the oriented FF amplitude
    ! Use dqag from QUADPACK for this purpose

    help_p = (/qx, qy, qz, R, 2d0*p_val/)
    call twodim_integral_variable_bounds(&
      -1d0, 1d0, ymin_func, ymax_func, &
      help_p, 5, ff_real_part, &
      real_ff_superball)

    ! Return absolute value squared times contrast
    ff_ampl_superball_oriented =&
      (SLDsuperball-SLDmatrix)*&
      2d0 * R**2 / qz * real_ff_superball

    contains
      ! define inner bounds of two dimensional integral
      double precision function ymin_func(x, p, Np)
        double precision, intent(in) :: x
        double precision, dimension(Np), intent(in) :: p
        integer, intent(in) :: Np
        ymin_func = -(1d0-abs(x)**p(5))**(1d0/p(5))
      end function

      double precision function ymax_func(x, p, Np)
        double precision, intent(in) :: x
        double precision, dimension(Np), intent(in) :: p
        integer, intent(in) :: Np
        ymax_func = (1d0-abs(x)**p(5))**(1d0/p(5))
      end function

      ! define integrand
      double precision function ff_real_part(x,y, p, Np)
        double precision, intent(in) :: x, y
        double precision, dimension(Np), intent(in) :: p
        integer, intent(in) :: Np

        double precision :: qx, qy, qz, R, n_exp, zval
        qx = p(1)
        qy = p(2)
        qz = p(3)
        R = p(4)
        n_exp = p(5)
        zval = abs(&
          1d0 - abs(x)**n_exp - abs(y)**n_exp&
          )**(1d0/n_exp)
        ff_real_part = sin(qz*R*zval)*cos(qy*R*y + qx*R*x)
      end function
  end function ff_ampl_superball_oriented

  subroutine oriented_formfactor(&
    q, R, p_val,&
    SLDsuperball, SLDmatrix, alpha, beta,&
    Nq, ff_int)
    ! Subroutine to calculate oriented FF ff_int
    ! over a range of q using multiple cores via OMP
    double precision, dimension(Nq), intent(in) :: q
    double precision, intent(in) :: R, p_val
    double precision, intent(in) :: SLDsuperball,SLDmatrix
    double precision, intent(in) :: alpha, beta
    integer, intent(in) :: Nq
    integer, parameter :: Np=6
    double precision, dimension(Np) :: p
    double precision,dimension(Nq),intent(out)::ff_int
    integer :: iq

    p = (/R, p_val, SLDsuperball, SLDmatrix, alpha, beta/)

    !$omp parallel
    !$omp do
    do iq=1, Nq
      ff_int(iq) =&
        abs(ff_ampl_superball_oriented(q(iq), p, Np))**2
    end do
    !$omp end do
    !$omp end parallel
  end subroutine oriented_formfactor

  subroutine formfactor(&
    q, R, p_val, SLDsuperball, SLDmatrix, sigR,&
    x_herm, w_herm, x_leg, w_leg,&
    N_gh, N_gl, &
    Nq, ff_int)
    ! Subroutine to call orientationally averaged
    ! size distribution averaged formfactor
    double precision, dimension(Nq), intent(in) :: q
    double precision, intent(in) :: R, p_val
    double precision, intent(in) :: SLDsuperball,SLDmatrix
    double precision, intent(in) :: sigR
    double precision,dimension(N_gh),intent(in):: x_herm
    double precision,dimension(N_gh),intent(in):: w_herm
    double precision,dimension(N_gl),intent(in):: x_leg
    double precision,dimension(N_gl),intent(in):: w_leg
    integer, intent(in) :: Nq, N_gh, N_gl
    double precision, dimension(Nq), intent(out) :: ff_int

    integer, parameter :: Np=6

    double precision :: current_R, current_phi
    double precision :: current_th, current_sinth
    double precision :: w_R_i, w_phi_i, w_theta_i
    double precision :: intsum_norm
    double precision, dimension(Nq) :: hff, intsum_ff

    integer :: iR, ith, iphi
    double precision :: integrand_prefacs

    intsum_ff = 0d0
    intsum_norm = 0d0
    n_integration_cuts = 1
    do iR=1, N_gh
      ! gaussian hermite quadrature
      write(*,'(1a1,i0,A2,$)') char(13),&
        iR * 100/N_gh, " %"

      current_R = R*dexp(sq2 * x_herm(iR) * sigR)
      w_R_i = w_herm(iR)
      do ith=1, N_gl
        ! translate -1 to 1 for 0 to pi/2
        current_th = pi/4d0 * (x_leg(ith) + 1d0)
        current_sinth = sin(current_th)
        w_theta_i = pi/4d0 * w_leg(ith)

        do iphi=1, N_gl
          ! translate -1 to 1 for 0 to pi/2
          current_phi = pi/4d0 * (x_leg(iphi) + 1d0)
          w_phi_i =  pi/4d0 * w_leg(iphi)
          call oriented_formfactor(q, current_R, p_val,&
            SLDsuperball, SLDmatrix, &
            current_phi, current_th, Nq, hff)

          integrand_prefacs =& 
            w_R_i * w_phi_i * w_theta_i * current_sinth

          intsum_ff = intsum_ff + integrand_prefacs * hff
          intsum_norm = intsum_norm + integrand_prefacs
        end do
      end do
    end do
    ff_int = intsum_ff/intsum_norm
    print *, " Done."
  end subroutine formfactor

  subroutine twodim_integral_variable_bounds(xmin, xmax, &
      ymin_func, ymax_func, &
      p, Np, &
      integrand_func, integrand_res)
    ! Subroutine to perform two dimensional integrals
    ! with arbitrary bounds
    ! Input:
    ! xmin      -- lower bound, outer integral
    ! xmax      -- upper bound, outer integral
    ! ymin_func -- lower bound, inner integral (function)
    ! ymax_func -- upper bound, inner integral (function)
    ! p         -- parameter array for integrand
    ! Np        -- Length of p
    ! integrand_func -- function to be integrated
    ! Output:
    ! integrand_res -- result of two-dim integral

    double precision, intent(in) :: xmin, xmax
    external ymin_func
    external ymax_func
    double precision, dimension(Np), intent(in) :: p
    integer, intent(in) :: Np
    external integrand_func
    double precision, intent(out) :: integrand_res

    ! helper variables for the call of QUADPACK
    double precision :: abserr1, abserr2
    integer :: neval1, ier1, last1, neval2, ier2, last2
    integer, dimension(50) :: iwork1, iwork2
    double precision, dimension(200) :: work1, work2
    double precision, dimension(Np+1) :: help_params

    interface
      ! define expected format of ymin_func, ymax_func
      ! and integrand_func
      double precision function ymin_func(x, p, Np)
        double precision, intent(in) :: x
        double precision, dimension(Np), intent(in) :: p
        integer, intent(in) :: Np
      end function

      double precision function ymax_func(x, p, Np)
        double precision, intent(in) :: x
        double precision, dimension(Np), intent(in) :: p
        integer, intent(in) :: Np
      end function

      double precision function integrand_func&
        (x, y, p, Np)
        double precision, intent(in) :: x, y
        double precision, dimension(Np), intent(in) :: p
        integer, intent(in) :: Np
      end function
    end interface

    help_params(1:Np) = p
    help_params(Np+1) = 0d0
    call dqag(&
      integrate12, xmin, xmax, 0d0, 1d-10, 6,&
      integrand_res, abserr1, neval1, ier1,&
      n_integration_cuts,4*n_integration_cuts,&
      last1, iwork1, work1)

    contains
      double precision function integrate12(x)
        double precision :: x
        double precision :: ymin, ymax
        ymin = ymin_func(x, p, Np)
        ymax = ymax_func(x, p, Np)
        help_params(Np+1) = x
        call dqag (&
          integrate02, ymin, ymax, 0d0, 1d-10, 6,&
          integrate12, abserr2, neval2, ier2,&
          n_integration_cuts,&
          4*n_integration_cuts,&
          last2, iwork2, work2)
      end function integrate12

      double precision function integrate02(y)
        double precision :: y
        double precision :: x
        x = help_params(Np+1)
        integrate02 = integrand_func(x, y, p, Np)
      end function integrate02
  end subroutine twodim_integral_variable_bounds
  \end{lstlisting}
\end{document}